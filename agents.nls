__includes ["dijkstra.nls" 
  "basic_passenger_handling.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
  
                  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
                  ; New local variables for students.
                  ; You can create any new local variable you want. Just declare them here.
  bus-route       ; Every bus has a route
  direction       ; 1 - from begin to end, -1 - from end to begin
  next-stops      ; List of upcoming stops
  capacity        ; Capacity of the bus
  free-space      ; Current free space in the bus
  route-type      ; Circle (0)/line (1)/graph-based(2): true for line, false for circle
  connectivity-matrix ; The connectivity matrix
  
  waiting-passengers; This contains the total number of travellers in the system
  total-capacity  ; This contains the total capacity of all busses (only known by bus 24)
  weight-matrix   ; The weight matrix contains weights on all edges of the shortest route of all passengers
  
  passenger-orders;Here we put all bus orders which are off-route, so we know where to drop them off.
]

; Not allowed to create new global variables!!!

globals [graph dijkstra-lookup-table]

to init-buses
  ; Initialize your agents here.
  set direction 1
  set next-stops []
  set waiting-passengers 0
  set total-capacity 0
  set passenger-orders []
  
  if bus_id = 24 [set route-type 2]
  if bus_id = 25 [set bus-route [3 4 5 16 11 1 19 23 14 0 15 18 15 12 22 13 7 17 10 21 20 9 8 2 8 6 8 9]
    set route-type 0
    set next-stops bus-route]
  if bus_id = 26 [set bus-route [3 4 5 16 11]
    set route-type 1]
  if bus_id > 26 [set route-type 2]
  
  if bus_type = 1 [set capacity 12]
  if bus_type = 2 [set capacity 60]
  if bus_type = 3 [set capacity 150]
  set free-space capacity
  
  if bus_id = 24 [
    ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
    set graph [[22 15 14]    ; 0    - Amstel
      [11 19 23 7]  ; 1    - Amstelveenseweg
      [8]           ; 2    - Buikslotermeer
      [16 4 20 9]   ; 3    - Centraal
      [3 5 10]      ; 4    - Dam
      [4 16 10 17]  ; 5    - Evertsenstraat
      [8]           ; 6    - Floradorp
      [1 17 13]     ; 7    - Haarlemmermeerstation
      [2 6 9]       ; 8    - Hasseltweg
      [3 8 20]      ; 9    - Hendrikkade
      [4 5 17 13 21]; 10   - Leidseplein
      [1 16 17]     ; 11   - Lelylaan
      [20 15 22]    ; 12   - Muiderpoort
      [7 10 22 23]  ; 13   - Museumplein
      [0 23]        ; 14   - RAI
      [0 12 18]     ; 15   - Sciencepark
      [3 5 11]      ; 16   - Sloterdijk
      [5 7 10 11]   ; 17   - Surinameplein
      [15]          ; 18   - UvA
      [1 23]        ; 19   - VU
      [3 9 12 21]   ; 20   - Waterlooplein
      [10 20 22]    ; 21   - Weesperplein
      [0 12 13 21]  ; 22   - Wibautstraat
      [1 13 14 19]] ; 23   - Zuid
    
    set connectivity-matrix init-connectivity-matrix
    set dijkstra-lookup-table make-route-lookup-table
    set total-capacity capacity
  ]
end

to make-weight-matrix
  let K matrix:make-constant 24 24 0
  let counter1 0
  let counter2 0
  let counter3 0
  let number-of-passenger-at-each-stop count-passengers-at-each-stop
  let all-stops [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23] 
  
  foreach all-stops [ let value ?
    let shortest-route get-shortest-route current_stop value 
    
    let begin-node current_stop
    
    let weight item value number-of-passenger-at-each-stop / length shortest-route
    
    foreach shortest-route [
      let end-node ?
      if end-node != begin-node[
        matrix:set K begin-node end-node (matrix:get K begin-node end-node + weight) 
        set counter1 (counter1 + weight)
        set begin-node end-node
      ] 
    ]
  ]
  
  let relevant-stops []
  set relevant-stops lput current_stop relevant-stops
  foreach relevant-stops[
    let value ?
    let stop-passengers get-passengers-at-stop value
    foreach stop-passengers[
      let id item 0 ?
      let goal item 1 ?
      let shortest-route get-shortest-route value goal            
      
      let begin-node value
      let weight 1 / (length shortest-route)
      if length shortest-route > 1 [
        foreach shortest-route[
          let end-node ?
          if end-node != begin-node[
            matrix:set K begin-node end-node (matrix:get K begin-node end-node + weight)
            set counter2 (counter2 + weight)
            set begin-node end-node
          ]
        ]
      ]
    ]
  ]
  
  foreach bus_passengers[
    let id item 0 ?
    let goal item 1 ?
    let shortest-route get-shortest-route current_stop goal
    
    let begin-node current_stop
    let weight 1 / (length shortest-route)
    if length shortest-route > 1 [
      foreach shortest-route[
        let end-node ?
        if end-node != begin-node[
          matrix:set K begin-node end-node (matrix:get K begin-node end-node + weight * 5)
          set counter3 (counter3 + weight)
          set begin-node end-node
        ]
      ]
    ]
  ]
  write "Counter1 is"
  show counter1
  write "Counter2 is"
  show counter2
  write "Counter3 is"
  show counter3
  set weight-matrix K
  
end

to-report count-passengers-at-each-stop
  let passenger-at-stop-list []
  let relevant-stops [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23] 
  foreach relevant-stops[
    let value ?
    let stop-passengers get-passengers-at-stop value
    set passenger-at-stop-list lput length stop-passengers passenger-at-stop-list 
  ]
  
  set waiting-passengers sum passenger-at-stop-list
  
  report passenger-at-stop-list
end

to execute-actions
  write "Current stop is"
  show current_stop
  if route-type = 0 [
    if current_stop != -1 [
      ;show current_stop
      set next-stops lput current_stop next-stops
      set next-stops but-first next-stops
      
      bus-actions
    ]
  ]
  if route-type = 1[
    if current_stop != -1 [                                     ;check if we are not on the road
      let stop-index position current_stop bus-route             ;we check index of current stop and determine next-stops
      
      if (length next-stops) = 1 [
        write "Reached end, reverting direction!"
        set direction (direction * -1)]
      
      if direction = 1 [
        set next-stops sublist bus-route (stop-index + 1) length bus-route
      ]
      
      if direction = -1 [
        set next-stops reverse sublist bus-route 0 stop-index
      ]
      bus-actions
    ]
  ]
  if route-type = 2[
    ;show next-stops
    let required-length 2
    if current_stop != -1 [
      if length next-stops > 0 [set next-stops but-first next-stops] ;we reached destination, drop first of the list
      
      if length next-stops < required-length[                                      ;get new destination to add to list
        make-weight-matrix
        while [length next-stops < required-length][
          let last-stop current_stop
          if length next-stops != 0[set last-stop last next-stops]
          let max-weight 0
          let next-stop 0 ;if we cannot find any next stop, we just wait
          foreach item last-stop graph[
            let edge-weight matrix:get weight-matrix last-stop ?
            if edge-weight > max-weight[
              if not member? ? next-stops[
                set max-weight edge-weight
                set next-stop ?
              ]
            ]
          ]
          ifelse next-stop = 0 [
            set required-length (required-length - 1) ;we cannot decide about a stop yet
                                                      ;show next-stops
          ][
          set next-stops lput next-stop next-stops
          ;show next-stops
          ]
        ]
      ]
     write "Doing bus actions"
     bus-actions
    ]
  ]
  
  if bus_id = 24 [create-new-capacity]
  if (current_stop = -1) and (length next-stops > 0)[travel-to item 0 next-stops]
end

to create-new-capacity
  while [waiting-passengers > 0.8 * total-capacity] 
  [ add-bus 2 
    set total-capacity (total-capacity + 60)
  ]
end
