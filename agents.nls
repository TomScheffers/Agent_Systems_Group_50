extensions [matrix]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
  
                  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
                  ; New local variables for students.
                  ; You can create any new local variable you want. Just declare them here.
  bus-route       ; Every bus has a route
  direction       ; 1 - from begin to end, -1 - from end to begin
  next-stops      ; List of upcoming stops
  capacity        ; Capacity of the bus
  free-space      ; Current free space in the bus
  route-type      ; Circle (0)/line (1)/graph-based(2): true for line, false for circle
  connectivity-matrix ; The connectivity matrix
  
  total-passengers; This contains the total number of travellers in the system
  total-capacity  ; This contains the total capacity of all busses (only known by bus 24)
  travel-matrix   ; This matrix contains all travelling
  weight-matrix   ; The weight matrix contains weights on all edges of the shortest route of all passengers
]

; Not allowed to create new global variables!!!

globals [graph]

to init-buses
  ; Initialize your agents here.
  set direction 1
  set next-stops []
  if bus_id = 24 [set route-type 2]
  if bus_id = 25 [set bus-route [3 4 5 16 11 1 19 23 14 0 15 18 15 12 22 13 7 17 10 21 20 9 8 2 8 6 8 9]
    set route-type 0
    set next-stops bus-route]
  if bus_id = 26 [set bus-route [3 4 5 16 11]
    set route-type 1]
  if bus_id > 26 [set route-type 2]
  if bus_type = 1 [set capacity 12]
  if bus_type = 2 [set capacity 60]
  if bus_type = 3 [set capacity 150]
  set free-space capacity
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14]    ; 0    - Amstel
    [11 19 23 7]  ; 1    - Amstelveenseweg
    [8]           ; 2    - Buikslotermeer
    [16 4 20 9]   ; 3    - Centraal
    [3 5 10]      ; 4    - Dam
    [4 16 10 17]  ; 5    - Evertsenstraat
    [8]           ; 6    - Floradorp
    [1 17 13]     ; 7    - Haarlemmermeerstation
    [2 6 9]       ; 8    - Hasseltweg
    [3 8 20]      ; 9    - Hendrikkade
    [4 5 17 13 21]; 10   - Leidseplein
    [1 16 17]     ; 11   - Lelylaan
    [20 15 22]    ; 12   - Muiderpoort
    [7 10 22 23]  ; 13   - Museumplein
    [0 23]        ; 14   - RAI
    [0 12 18]     ; 15   - Sciencepark
    [3 5 11]      ; 16   - Sloterdijk
    [5 7 10 11]   ; 17   - Surinameplein
    [15]          ; 18   - UvA
    [1 23]        ; 19   - VU
    [3 9 12 21]   ; 20   - Waterlooplein
    [10 20 22]    ; 21   - Weesperplein
    [0 12 13 21]  ; 22   - Wibautstraat
    [1 13 14 19]] ; 23   - Zuid
  set connectivity-matrix init-connectivity-matrix
  set total-passengers 0
  set total-capacity 0
  if bus_id = 24 [set total-capacity capacity]
end

to-report init-connectivity-matrix  
  ;show "Starting to init the connectivity graph from here"
  let G matrix:make-constant 24 24 0
  
  let row-counter 0
  foreach graph [let row item row-counter graph
    let col-counter 0
    foreach row [let col item col-counter row
      matrix:set G row-counter col 1
      set col-counter (col-counter + 1)]
    set row-counter (row-counter + 1)]
  ;show connectivity-matrix
  report G
end

to make-weight-matrix
    let K matrix:make-constant 24 24 0
    let relevant-stops item current_stop graph            ;all connected stops
    set relevant-stops lput current_stop relevant-stops   ;relevant stops - we do not want to work with a fully informed graph
    foreach relevant-stops[
      let value ?
      let stop-passengers get-passengers-at-stop value
      foreach stop-passengers[
        let id item 0 ?
        let goal item 1 ?
        set total-passengers (total-passengers + 1)
        let shortest-route dijkstra value goal             ;SUBSTITUTE THIS FOR A LOOKUP LIST WITH ALL THE DIJKSTRA VALUES
        
        let begin-node value
        if length shortest-route > 1 [
          foreach shortest-route[
            let end-node ?
            if end-node != begin-node[
              matrix:set K begin-node end-node (matrix:get K begin-node end-node + 1)
              set begin-node end-node
            ]
          ]
        ]
        ]
      ]
    set weight-matrix K
end

to execute-actions
  if route-type = 0 [
    if current_stop != -1 [
      show current_stop
      set next-stops lput current_stop next-stops
      set next-stops but-first next-stops
      
      drop-passengers    
      pickup-passengers
      move-to-next
    ]
  ]
  if route-type = 1[
    if current_stop != -1 [                                     ;check if we are not on the road
      let stop-index position current_stop bus-route             ;we check index of current stop and determine next-stops
      
      if (length next-stops) = 1 [
        write "Reached end, reverting direction!"
        set direction (direction * -1)] 
      
      if direction = 1 [
        set next-stops sublist bus-route (stop-index + 1) length bus-route 
      ]
      
      if direction = -1 [
        set next-stops reverse sublist bus-route 0 stop-index
      ]
      
      drop-passengers    
      pickup-passengers
      move-to-next
    ]
  ]
  if route-type = 2[
    show next-stops
    let required-length 6
    if current_stop != -1 [
      if length next-stops > 0 [set next-stops but-first next-stops] ;we reached destination, drop first of the list
      
      if length next-stops < required-length[                                      ;get new destination to add to list
        make-weight-matrix
        while [length next-stops < required-length][
          let last-stop current_stop
          if length next-stops != 0[set last-stop last next-stops]
          let max-weight 0
          let next-stop 0 ;if we cannot find any next stop, we just wait
         foreach item last-stop graph[
           let edge-weight matrix:get weight-matrix last-stop ?
           if edge-weight > max-weight[
             if not member? ? next-stops[
                set max-weight edge-weight
                set next-stop ?
               ]
             ]
           ]
        ifelse next-stop = 0 [
          set required-length (required-length - 1) ;we cannot decide about a stop yet
          show next-stops
          ][
          set next-stops lput next-stop next-stops
          show next-stops
          ]
        ]
      ]
      drop-passengers    
      pickup-passengers
      move-to-next
      ]
    ]
  
  if bus_id = 24 [create-new-capacity]
  if (current_stop = -1) and (length next-stops > 0)[travel-to item 0 next-stops]
end

to pickup-passengers
  ;pick up passengers en route
  let stop-passengers get-passengers-at-stop current_stop
  
  foreach stop-passengers[
    let id item 0 ?
    let goal item 1 ?
    if member? goal next-stops[     ;This checks if the goal is en route
      if free-space > 0 [
        write "Picked up passenger with id:"
        show id
        pick-up-passenger id
        set free-space (free-space - 1)
      ]
    ]
  ]
end

to drop-passengers
  foreach bus_passengers[
    let id item 0 ?
    let goal item 1 ?
    if goal = current_stop [
      write "Dropped of passenger with id:"
      show id
      drop-off-passenger id
      set free-space (free-space + 1)
    ]
  ]
end

to move-to-next
  if length next-stops > 0 
    [travel-to item 0 next-stops]
end




to create-new-capacity
  while [total-capacity < (1.2 * total-passengers)][
    add-bus 3
    set total-capacity (total-capacity + 150)
    ]
end






to-report dijkstra [s d]
  ifelse s = d [show "Desinatoin and start are equal"
    report (list s)] ; if the start and destination are equal
  [ let A setup-graph matrix:copy connectivity-matrix 999999999 1
    
    if d = 0 [ set d s]
    set A exchange-node matrix:copy A 0 s
    
    
    let W matrix:make-constant 24 24 0
    foreach [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23] [
      let value ?
      matrix:set W 0 value value + 1
      matrix:set W 1 value matrix:get A 0 value
    ]
    
    let F matrix:make-constant 24 2 0
    foreach [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23] [
      let value ? 
      matrix:set F value 0 matrix:get A 0 value
      matrix:set F value 1 value + 1
    ]
    
    let F2 matrix:submatrix matrix:copy F 1 0 24 2
    
    let L 2
    
    while [L <= 23][
      
      let number-of-rows item 0 matrix:dimensions F2
      set L ( L + 1 )
      
      foreach n-values 50 [?] [ set F2 sort-rows F2 0 ]; perform sorting algorithm 25 times, to make sure it works correct. Probably a bit overkill    
      let k matrix:get F2 0 1 
      
      matrix:set W (L - 1)  0 k       
      
      set F2 matrix:submatrix F2 1 0 number-of-rows 2
      
      set number-of-rows item 0 matrix:dimensions F2
      
      let iteration-list n-values number-of-rows [?+1]
      
      foreach iteration-list [let value ? 
        let x-coor (matrix:get F2 value 1 - 1)
        if matrix:get F x-coor 0 > (matrix:get F (k - 1) 0 + matrix:get A (k - 1) x-coor  ) [
          matrix:set F x-coor 0 (matrix:get F (k - 1) 0 + matrix:Get A (k - 1) x-coor  )
          matrix:set F2 value 0 matrix:get F x-coor  0 
        ]
      ]
      
      set iteration-list n-values 23 [? + 1]
      ;show iteration-list
      foreach iteration-list [let value ?   
        matrix:set W (L - 1) value matrix:get F value 0
      ]    
    ]
    
    ifelse d = s [ set L (list 1)] [set L (list d) ]
    
    let small-e matrix:get W 23 d         
    set L list-dijkstra L W s d
    report reverse L
  ]
  
end

to-report setup-graph [G b s]
  let bus-stop-list [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
  
  
  if s = 1[
    foreach bus-stop-list[ let row item ? bus-stop-list
      foreach bus-stop-list [let col item ? bus-stop-list
        let value matrix:get G row col
        if value = 0 [matrix:set G row col b]
      ]
    ]
    report G
  ]
  
  if s = 2[
    foreach bus-stop-list[ let row item ? bus-stop-list
      foreach bus-stop-list [let col item ? bus-stop-list
        let value matrix:get G row col
        if value = b [matrix:set G row col 0]
      ]
    ]
    report G
  ]
end

to-report exchange-node [G a b]
  matrix:swap-columns G a b
  matrix:swap-rows G a b
  report G
end

to-report sort-rows [G col]
  let a item 0 matrix:dimensions G
  let b item 1 matrix:dimensions G
  
  set a (a - 1)
  let row-list n-values a [?]
  
  foreach row-list [let row item ? row-list
    let row-plus-one row + 1
    if matrix:get G row-plus-one col < matrix:get G row col [
      matrix:swap-rows G row-plus-one row
    ]
  ] 
  report G
end

to-report list-dijkstra [L W s d]
  let index item 0 matrix:dimensions W
  
  while [ index > 0 ] [
    ifelse matrix:get W 1 (d   )   = matrix:get W 23 (d )  [set L lput s L
      set index 0] [
    let index2 item 0 matrix:dimensions W
    
    while [ index2 > 0 ] [
      ifelse matrix:get W (index2 - 1) (d  ) < matrix:get W (index2 - 2) (d  ) [    
        set L lput (matrix:get W (index2 - 1  ) 0  - 1) L
        set L list-dijkstra L W s (matrix:get W (index2 - 1) 0  - 1)
        set index2 0
      ] [set index2 (index2 - 1)]
      set index 0
    ]
      ]
  ] 
  report L
end